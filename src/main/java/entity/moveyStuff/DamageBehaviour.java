package entity.moveyStuff;

import entity.*;


// Damage move behaviour framework was generated by ChatGPT
public abstract class DamageBehaviour implements MoveBehaviour {

    @Override
    public void execute(Move move,
                        PokemonTeam userTeam,
                        PokemonTeam targetTeam,
                        BattleStats userBattleStats,
                        BattleStats targetBattleStats) {
        double damage = getBaseDamage(move, userTeam, targetTeam, userBattleStats, targetBattleStats)
                    * getTypeModifier(move, targetTeam);
        targetTeam.getActivePokemon().takeDamage((int)Math.round(damage));
    }

    /*This should not be in this class as it violate SRP: This class contains behaviour that
    outlines what a move actually does and it makes no sense to also make it responsible for
    determinging if the move actually gets to exhibit that behaviour.
    private boolean hitSucceeds(Move move,
                                BattleStats userBattleStats,
                                BattleStats targetBattleStats) {
        return ((float) move.getMoveAccuracy() / 100 *
                userBattleStats.getStat(StatType.ACCURACY) *
                targetBattleStats.getStat(StatType.EVASION) >
                (Math.random() * 256) / 255 );
    }*/

    private static double getTypeModifier(Move move, PokemonTeam targetTeam) {
        return PokemonType.valueOf(move.getMoveType())
                .getEffectivenessAgainst(targetTeam.getActivePokemon().getTypes());
    }

    abstract int getBaseDamage(Move move,
                               PokemonTeam userTeam,
                               PokemonTeam targetTeam,
                               BattleStats userBattleStats,
                               BattleStats targetBattleStats);}

    /*The following sequence of code is what my initial implementation of this class was;
    however, I realised that it is a clear violation of the SRP as this class would be
    responsible for the behaviour of special damage moves, phsycial damage moves,
    one-hit-ko moves and several more. I have decided to instead make this class abstract
    and move all specific logic calculations for the different move classess into their own
    child classes.

    private int calculateDamage(Move move,
                                PokemonTeam userTeam,
                                PokemonTeam targetTeam,
                                BattleStats userBattleStats,
                                BattleStats targetBattleStats) {
        if (Objects.equals(move.getMoveClass(), "physical")) {
            float baseDamage = (2* move.getMovePower() *
                    (userBattleStats.getStat(StatType.ATTACK)/
                            targetBattleStats.getStat(StatType.DEFENSE))/50 +2);

            double modifier = 1;
            for(String type : userTeam.getActivePokemon().getTypes()) {
                modifier *= PokemonType.valueOf(type).getEffectivenessAgainst(targetTeam.getActivePokemon().getTypes());

            }

            return (int) (baseDamage * modifier);
        } else if(Objects.equals(move.getMoveClass(), "special"))
            {
            float baseDamage = (2 * move.getMovePower() *
                    (userBattleStats.getStat(StatType.SPECIAL_ATTACK)/
                            targetBattleStats.getStat(StatType.SPECIAL_DEFENSE))/50 +2);

                double typeModifier = getTypeModifier(userTeam, targetTeam);

                return (int) (baseDamage * typeModifier);
        } else //OneHitKnockOutBehaviour
        {
            return userTeam.getActivePokemon().getBaseStats().getMaxHp();
        }
    }

}*/

