package entity;

//Current code for this class was generated by ChatGPT. Scroll below for my initial
//implementation.

import java.util.EnumMap;
import java.util.Map;

public class BattleStats {

    private final BaseLevelStats baseStats;

    // Current effective stats in battle
    private final Map<StatType, Float> currentStats = new EnumMap<>(StatType.class);

    // Stage modifiers for stats (-6 to +6)
    private final Map<StatType, Integer> statStages = new EnumMap<>(StatType.class);

    // Base values mapped by StatType for generic calculation
    private final Map<StatType, Float> baseStatValues = new EnumMap<>(StatType.class);

    public BattleStats(BaseLevelStats baseStats) {
        this.baseStats = baseStats;

        initializeBaseStats();
        resetBattleModifiers(); // sets current stats and stages
    }

    // -------------------- Initialization -------------------- //

    private void initializeBaseStats() {
        baseStatValues.put(StatType.ATTACK, (float) baseStats.getAttack());
        baseStatValues.put(StatType.DEFENSE, (float) baseStats.getDefense());
        baseStatValues.put(StatType.SPECIAL_ATTACK, (float) baseStats.getSpecialAttack());
        baseStatValues.put(StatType.SPECIAL_DEFENSE, (float) baseStats.getSpecialDefense());
        baseStatValues.put(StatType.SPEED, (float) baseStats.getSpeed());
        baseStatValues.put(StatType.ACCURACY, 1f); // neutral multiplier
        baseStatValues.put(StatType.EVASION, 1f);  // neutral multiplier

        for (StatType stat : StatType.values()) {
            statStages.put(stat, 0); // all stages start at 0
        }
    }

    // -------------------- Stage Modification -------------------- //

    /**
     * Modify a stat by a given stage change (-6 to +6 total)
     * Automatically recalculates the effective stat.
     */
    public void modifyStat(StatType stat, int stageChange) {
        int newStage = clampStage(statStages.get(stat) + stageChange);
        statStages.put(stat, newStage);
        recalcStat(stat, newStage);
    }

    /** Resets all non-HP stats and stages */
    public void resetBattleModifiers() {
        for (StatType stat : StatType.values()) {
            statStages.put(stat, 0);
            recalcStat(stat, 0);
        }
    }

    // -------------------- Recalculation -------------------- //

    /** Recalculates a stat based on its stage. While all these calculations
     * are relatively simple and straightforward, dividing them ensures that we
     * cans easily alter how stats are calcualte down the road*/
    private void recalcStat(StatType stat, int stage) {
        float baseValue = baseStatValues.get(stat);

        // Accuracy and Evasion are multipliers only, others scale with base value
        if (stat == StatType.ACCURACY)  {
            currentStats.put(stat, accuracyStageMultiplier(stage));
        } else if (stat == StatType.EVASION) {
            currentStats.put(stat, evasionStageMultiplier(stage));
        }
        else {
            currentStats.put(stat, baseValue * statStageMultiplier(stage));
        }
    }

    /** Converts stage (-6 to +6) to multiplier */
    private float statStageMultiplier(int stage) {
        if (stage >= 0) return (2f + stage) / 2f;
        else return 2f / (2f - stage);
    }

    private float accuracyStageMultiplier(int stage) {
        if (stage >= 0) return (3f + stage) / 3f;
        else return 3f / (3f - stage);
    }

    private float evasionStageMultiplier(int stage) {
        if (stage >= 0) return 3f / (3f + stage);
        else return (3f - stage) / 3f;
    }


    /** Clamp stage to [-6, 6] */
    private int clampStage(int stage) {
        return Math.max(-6, Math.min(6, stage));
    }


    // -------------------- Current Stat Access -------------------- //

    public float getStat(StatType stat) {
        return currentStats.get(stat);
    }

    public int getStage(StatType stat) {
        return statStages.get(stat);
    }
}


/* Following code was written by me. Replaced with more concise and elegant code
generated by ChatGPT above.
public class BattleStats {
    private final BaseLevelStats baseStats;
    private int currentHP;
    private float currentAttack;
    private float currentDefense;
    private float currentSpecialAttack;
    private float currentSpecialDefense;
    private float currentSpeed;
    private float currentAccuracy;
    private float currentEvasion;
    private int attackStage;
    private int defenseStage;
    private int specialAttackStage;
    private int specialDefenseStage;
    private int evasionStage;
    private int accuracyStage;

    public BattleStats(BaseLevelStats baseStats) {
        this.baseStats = baseStats;
        this.currentHP = baseStats.getHp();
        this.currentAttack = baseStats.getAttack();
        this.currentDefense = baseStats.getDefense();
        this.currentSpecialAttack = baseStats.getSpecialAttack();
        this.currentSpecialDefense = baseStats.getSpecialDefense();
        this.currentSpeed = baseStats.getSpeed();
        this.currentAccuracy = 1;
        this.currentEvasion = 1;
        attackStage = 0;
        defenseStage = 0;
        specialAttackStage = 0;
        specialDefenseStage = 0;
        evasionStage = 0;
        accuracyStage = 0;
    }

    //Method for reseting all stats save for HP. This should be done at the end
    //of every battle and whenever a Pokemon moves to the bench.
    public void resetBattleModifiers() {
        this.currentAttack = baseStats.getAttack();
        this.currentDefense = baseStats.getDefense();
        this.currentSpecialAttack = baseStats.getSpecialAttack();
        this.currentSpecialDefense = baseStats.getSpecialDefense();
        this.currentSpeed = baseStats.getSpeed();
        this.currentAccuracy = 1;
        this.currentEvasion = 1;
    }

    public int getCurrentHP() {
        return currentHP;
    }

    public void takeDamage(int damage) {
        this.currentHP -= damage;
    }

    public float getCurrentAttack() {
        return currentAttack;
    }

    public void modifyAttack(int stageChange) {
        int newAttackStage = attackStage + stageChange;
        if (-6 <= newAttackStage && newAttackStage <= 6 ) {
            attackStage = newAttackStage;
            if (newAttackStage >= 0)
                currentAttack = Math.floorDiv((2 + newAttackStage) * baseStats.getAttack(), 2);
            else
                currentAttack = Math.floorDiv(2 * baseStats.getAttack(), (2 + newAttackStage));
        }
        else
            throw new IllegalArgumentException("Attack cannot go any lower");
    }

    public float getCurrentDefense() {
        return currentDefense;
    }

    public void modifyDefense(int stageChange) {
        int newDefenseStage = defenseStage + stageChange;
        if (-6 <= newDefenseStage && newDefenseStage <= 6 ) {
            attackStage = newDefenseStage;
            if (newDefenseStage >= 0)
                currentAttack = Math.floorDiv((2 + newDefenseStage) * baseStats.getAttack(), 2);
            else
                currentAttack = Math.floorDiv(2 * baseStats.getAttack(), (2 + newDefenseStage));
        }
        else
            throw new IllegalArgumentException("Attack cannot go any lower");
    }

    public float getCurrentSpecialAttack() {
        return currentSpecialAttack;
    }

    public void setCurrentSpecialAttack(float currentSpecialAttack) {
        this.currentSpecialAttack = currentSpecialAttack;
    }

    public float getCurrentSpecialDefense() {
        return currentSpecialDefense;
    }

    public void setCurrentSpecialDefense(float currentSpecialDefense) {
        this.currentSpecialDefense = currentSpecialDefense;
    }

    public float getCurrentSpeed() {
        return currentSpeed;
    }

    public void setCurrentSpeed(float currentSpeed) {
        this.currentSpeed = currentSpeed;
    }

    public float getCurrentAccuracy() {
        return currentAccuracy;
    }

    public void setCurrentAccuracy(float currentAccuracy) {
        this.currentAccuracy = currentAccuracy;
    }

    public float getCurrentEvasion() {
        return currentEvasion;
    }

    public void setCurrentEvasion(float currentEvasion) {
        this.currentEvasion = currentEvasion;
    }
}
 */
