package use_case.generate_random_battle;

import entity.Move;
import entity.Pokemon;
import entity.PokemonTeam;
import factory.Factory;
import factory.pokemonFactory;
import use_case.start_battle.*;
import java.util.Random;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

//Framework of this interactor was generated by ChatGPT
public class GenerateRandomBattleInteractor implements GenerateRandomBattleInputBoundary {

    private final Factory factory;
    private final StartBattleInputBoundary startBattleInteractor;

    public GenerateRandomBattleInteractor(
            Factory factory,
            StartBattleInputBoundary startBattleInteractor) {

        this.factory = factory;
        this.startBattleInteractor = startBattleInteractor;
    }

    public void execute() {

        // Create two random 6-Pok√©mon teams
        PokemonTeam team1 = generateRandomTeam();
        PokemonTeam team2 = generateRandomTeam();

        // Pass these teams into the StartBattle Use Case
        StartBattleInputData data = new StartBattleInputData(team1, team2);
        startBattleInteractor.execute(data);

        // After StartBattleInteractor fills its output,
        // presenter is notified automatically

        /*My decision to have this interactor depend on another interactor is something
        I feel to be valid for the following reasons:
        - Interactors classes are at the same level, thus there is no violation of the
        dependency inversion principle
        - Having separate output boundaries for this class would not make any sense
        as the end result that we wish to display to the user must be the same result
        that is presented when calling the Battle interactor
         */
    }

    private PokemonTeam generateRandomTeam() {
        PokemonTeam team = new PokemonTeam();
        Random rand = new Random();

        for (int i = 0; i < 6; i++) {

            Pokemon p = new pokemonFactory(String.valueOf(rand.nextInt(152))).getPokemon();
            List<Move> randomSelectedMoves = new ArrayList<Move>();

            for (int j = 0; j < 3; j++) {
                Move move = p.getMoves()[rand.nextInt(p.getMoves().length)];
                randomSelectedMoves.add(move);
            }
            team.addPokemon(createPokemonWithMoves(p, randomSelectedMoves));
        }
        return team;
    }

    private Pokemon createPokemonWithMoves(Pokemon original, List<Move> selectedMoves) {
        Pokemon newPokemon = new Pokemon(
                original.getName(),
                original.getBaseStats(),
                original.getTypes(),
                original.getFrontSpriteUrl(),
                original.getBackSpriteUrl()
        );

        // Set the selected moves (up to MAX_SELECTED_MOVES_PER_POKEMON = 4)
        Move[] movesArray = newPokemon.getMoves();
        for (int i = 0; i < Math.min(4, selectedMoves.size()); i++) {
            movesArray[i] = selectedMoves.get(i);
        }

        return newPokemon;
    }
}
